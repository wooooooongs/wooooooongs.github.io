---
title:  "[Network] 컴퓨터네트워크 ?장 정리"
excerpt: "IOS환경 메모 어플에서 작성하여 서식 변환이 필요"

categories:
  - Network
tags:
  - [Network]

toc: true
toc_sticky: true
 
date: 2021-12-19
last_modified_at: 2021-12-19
---


2.6 Content Distribution Networks (CDNs)

정의
보통 스트리밍 서비스는 전 세계에 끊임없이 안정적으로 제공되어야 하는데 이는 굉장히 힘들다.가장 단순한 방법은 하나의 데이터 센터를 두는 것인데 이것은 문제점이 다양하다.
	0.	client - center 간 거리가 멀 때 링크에 따라 종단간 처리율이 다르기 때문에 불안정함
	0.	인기있는 비디오는 ISP들에게 중복 비용을 지불하여야 해서 비효율적이다.
	0.	에러 발생 시 서비스 전체에 피해 발생
따라서 전 세계에 엄청난 양의 데이터를 전송하기 위해 콘텐츠 분배 네트워크를 이용한다. 다수의 지점에 분산된 서버를 운용함으로써 congestion을 줄이고 최상의 서비스를 제공한다.
예시 
	0.	비디오 링크 클릭
	0.	host는 DNS 쿼리 전송 -> 로컬 DNS서버가 응답하여 해당 쿼리를 책임 DNS 서버로 전달
	0.	책임 DNS 서버는 쿼리를 KingCDN에 연결하기 위해 KingCDN의 호스트이름은 로컬DNS에 알려줌
	0.	로컬DNS는 KingCDN의 사설 DNS 서버에 들어가 두 번째 쿼리를 전송하고 콘텐츠 서버의 IP 주소를 받는다. 이 때 콘텐츠를 받을 서버가 할당됨.
	0.	로컬DNS는 콘텐츠를 제공할 CDN 서버의 IP주소를 host에게 알려줌.
	0.	주소에 직접 TCP연결을 설정하고 비디오에 대한 HTTP GET 요청을 한다. / 만약 DASH가 사용되면 서버는 먼저 서로 다른 버전의 비디오에 대한 URL 목록을 포함하는 manifest파일을 client에게 전송, 동적으로 비디오 조각 단위 데이터를 선택한다.

2.7 Socket Programing

인터넷을 사용하기 위해 5계층이 있고
소켓 : 앱 - 트랜스포트 사이 통로가 만들어져 있는데 
HTTP 프로토콜은 client의 앱 레이어에서 서버가 가지고 있는 컨텐츠를 전송해달라는 req를 보냄.
서버측의 HTTP는 메시지를 받고 관련 컨텐츠를 제공.
이 때 HTTP는 req 메시지를 만들긴 하지만 전송하는 기능을 가지고 있지 않음.
이 전송하는 기능을 transport계층에서 수행하며 이 req 메시지를 내려보낼 때 socket을 통해 전달한다.
이 통로로 만들어서 나오는 
HTTP는 loss가 발생하면 안되기 때문에 TCP를 통해 데이터를 전송하여야 함.
소켓프로그래밍은 소켓을 이용하는 애플리케이션을 정의하고
이 소켓을 통해 나오는 데이터를 전송하는 정의하는 것을 프로그래밍.

정의
소켓이란 process와 각 transport 프로토콜과 연결해주는 문이다.
client - server app레이어 간 데이터를 주고받을 수 있느 환경을 어떻게 구축하는지
socket을 통해 커뮤니케이션을 할 수 있도록 구현하는 것이 목표이다.

processor 역할: 애플리케이션이 실행되면 그 앱 실행되는 과정 속 cpu 메모리 애플리케이션이 네트워크를 사용하기 위해 하드웨어 자원, os 리소스 자원을 활용하는데 이 때 process를 할당


소켓은 두 가지(UDP, TCP)의 타입이 있음

예시
	0.	client가 연속된 data를 읽어 server로 보낸다
	0.	서버가 data를 받아 대문자로 characters를 변환한다.
	0.	client에게 수정된 정보(modified info)를 재전송한다.
	0.	client는 수정된 정보를 스크린에 표시한다.


UDP 소켓 프로그래밍 
	⁃	UDP는 비연결지향형이기 때문에 데이터를 전송할 때 handshaking의 과정이 없다.
	⁃	목적지의 IP주소와 port번호를 붙여 전송한다. 
	⁃	전송된 데이터가 뒤죽박죽이어도 신경쓰지 않음 -> 독립적인 패킷으로 보냄
	⁃	datagram을 비신뢰적인 전송을 통해 제공한다. (TCP는 segment)

server는 언제 데이터를 받을지 모르기 때문에 always on이어야 함
create socket, port = x:
serverSocket = socket(AF_INET,SOCK_DGRAM)
위 명령어를 통해 소켓과 포트를 객체로 할당

client 또한 마찬가지로 소켓을 생성한다. 

<UDP 소켓 생성 과정>


TCP 소켓 프로그래밍
	⁃	TCP는 연결지향형으로 서로 데이터를 주고받기 전 연결을 설정(handshake, establish)할 필요가 있다.
	⁃	연결의 한 쪽은 client socket, 한 쪽은 server socket에 연결.
	⁃	연결 생성 시 server socket address(IP, port number)와 client socket address와 연결하여 연관(associate)시킨다. 
	⁃	데이터를 보내려면 socket을 통해 데이터를 TCP 연결로 보내면 됨. (UDP와의 차이점: UDP는 서버가 패킷을 socket에 제공하기 전에 패킷에 address를 붙임)



	0.	server process 수행 -> client process는 server로 TCP 연결을 시도함(client에서 TCP 소켓을 생성하여서 가능)
	0.	client는 TCP 소켓을 생성할 때 server의 환영(welcome)소켓의 address(IP, port number)를 명시.
	0.	소켓 생성 후 3-way-handshaking을 하고 server와 TCP 연결을 설정.
	0.	이 핸드셰이킹 과정은 client와 server는 인식하지 못한다.
	0.	server는 연결을 시도하는 client을 위해 새로운 소켓을 생성한다.(conntectionSocket, 앞의 환영 소켓과는 다르다)


<환영 소켓과 연결 소켓>



<TCP 소켓 생성 과정>





Transport Layer


3.1 Transport Layer VS Network Layer

	•	Transport Layer: 각 hosts에서 동작하는 processes 사이의 논리적 통신을 제공
	•	Network Layer: 각 hosts 사이의 논리적 통신을 제공
hosts
houses
processes
kids
app messages
letter in envelopes
transport
demux to houst siblings
network
postal services
논리적 통신: process들이 동작하는 host들이 직접 연결된 것처럼 보인다는 것. 통신을 위한 물리적 하위 구조 상관없이 서로 메시지를 통신하기 위해서 트랜스포트 계층에서 제공하는 논리적 통신을 사용.

UDP/TCP
	•	UDP의 특징비신뢰적인 서비스, 순서대로 전달되지 않음, 무결성을 보장하지 않는다
	•	제공하는 서비스1. 프로세스 대 프로세스 데이터 전달2. 오류검출
	•	TCP의 특징신뢰적인 데이터 전달, 순서대로 정확하게 전달되도록 함.
	•	제공하는 서비스1. 흐름제어2. 혼잡제어3. 확인응답4. 타이머

3.2 Multiplexing / Demultiplexing


다중화(Multiplexing)
	⁃	sender에서 수행하며, 소켓들로부터 데이터를 모으고 데이터의 헤더 정보를 캡슐화한 세그먼트들을 네트워크 계층에 전달함.
	⁃	호스트는 IP주소, 포트넘버를 사용해 세그먼트를 해당하는 소켓에 전달하게 됨.


역다중화(Demultiplexing)
	⁃	호스트는 IP 데이터그램을 받는다
	⁃	각 데이터그램은 소스 IP주소와 목적지 IP주소를 갖고 하나의 전송계층 세그먼트를 갖는다.
	⁃	이 세그먼트들은 소스를 가지고 목적지 포트번호를 갖는다.
	⁃	전송계층 세그먼트를 포트번호와 헤더를 보고 올바른 소켓으로 보내는 작업

비연결형 다중화와 역다중화(UDP)
데이터그램이 UDP 소켓을 통해 데이터를 전송하고
IP, 포트넘버를 붙여서 감
수신측에서 세그먼트 안 포트번호를 확인하고 목적지 소켓으로 보낸다

	역다중화
	수신 호스트에 도착하면 출발지 포트번호는 필요없고 목적지 포트 번호만 검사함
	2개의 요소들의 집합(목적지 IP, 목적지 포트번호)	출발지 주소가 달라도 동일한 프로세스로 이동할 것임.	그럼 출발지 주소는 쓸 곳이 없다고 생각할 수 있지만, 수신 호스트가 응답할 때 사용됨.


연결형 다중화와 역다중화(TCP)
UDP 소켓과의 차이점, TCP 소켓은 4개의 요소들의 집합(출발지 IP, 포트넘버, 목적지 IP, 포트넘버)

	다중화
	TCP 소켓에서 생성되는 세그먼트는 4가지 요소를 포함하게 됨.

	역다중화
	수신 호스트에 도착했을 때, 4가지 요소가 모두 같아야 같은 소켓으로 접속 가능.	다중 접속 -> 세그먼트 증가 -> 많은 소켓 생성

따라서 비지속적 HTTP는 각 요청마다 다른 소켓을 가짐.

3.3 User Datagram Protocol(UDP)

특징
	•	데이터가 유실될 수 있다
	•	best effort(최선형) 전달 서비스를 추구한다.
	•	세그먼트를 송신하기 전 송신 transport layer 계층 개체들과 수신 transport layer 계층 개체들 사이에 handshake를 사용하지 않는다. -> 비연결형(connectionless)
	•	순서대로 전달하지 않는다.
	•	각 UDP 세그먼트는 독립적으로 전달된다.

사용처
	•	스트리밍 서비스(손실 허용, rate sensitive)
	•	DNS
	•	SNMP
	•	네트워크가 혼잡한 상태에 있고 자주 동작해야 할 때
	•	신뢰적인 데이터 전송도 필요함!!

세그먼트 구조

생각보다 많은 기능이 없어 구조가 단순함
(메시지 = payload)

UDP 사용 이유
	•	연결 설정에 사용되는 딜레이가 없다. (TCP는 핸드셰이크)
	•	간단하다, 수신부 송신부 간에 연결이 이루어지지 않음.
	•	작은 헤더사이즈
	•	혼잡제어를 하지 않는다. 센더에서 TCP보다 더 빠르게 데이터를 보낼 수 있음.


UDP checksum
전송된 세그먼트 안 에러를 발견함. 세그먼트가 도착했을 때 비트에 대한 변경사항이 있는지 검사하는 것
	•	송신부
	•	data 전송 과정에서 0이 1로 바뀌거나 그 반대처럼 에러발생할 수 있음.
	•	헤더 필드 안에 checksum 필드 안에 16개의 순서된 정수를 입력함
	•	체크섬의 방법에 의해계산이 됨.
	•	센더는 체크섬값을 UDP체크섬필드에 삽입한다.
	•	수신부
	•	헤드의 체크섬을 가지고 에러가 있는지 파악한다
	•	계산법


3.4 신뢰성 있는 데이터 전송의 원리(rdt)

	⁃	단방향성 전송만 가정한다(단, flow 관점에서 봤을 땐 양방향)
	⁃	FSM(finite-state machine, 유한상태 머신): 상태가 넘어갈 때 이벤트가 있고 액션이 있음.


rdt 1.0

가정: 채널이 안정적이라 패킷손실 등 에러가 하나도 없을 때
애플리케이션 레이어에서 트랜스포트 레이어로 데이터가 내려오면 패킷을 만들고
rdt_send(data), rdt_rcv(packet) 이벤트가 발생하면 그 아래의 액션을 취한다.
송신측에선 udt_send(packet)으로 패킷을 전송,수신측에선 deliver_data(data)로 데이터를 상위 계층으로 전달 이벤트가 일어나면 액션을 취함 


rdt 2.0

가정: 비트오류가 있는 채널 상에서의 신뢰적 데이터 전송, 모든 패킷이 순서대로 수신

과정: 송신측은 2개의 상태를 가진다.
	0.	데이터가 전달되길 기다리다 rdt_send()이벤트가 발생하면 송신자는 데이터, 체크섬을 포함한 패킷을 생성하고 udt_send()에 이를 담아 전송
	0.	송신자 프로토콜은 ACK/NAK을 기다린다. ACK - 다시 1로 돌아감NAK - 마지막 패킷을 재전송하고 다시 기다린다. 이 때 상위 계층으로부터 더 이상 데이터를 받을 수 없음.따라서 rdt_send() 이벤트는 발생할 수 없다. ACK을 받아야지 rdt_send 이벤트를 받을 수 있다.이 때문에 전송-후-대기(stop-and-wait) 프로토콜로 알려진다 



	•	비트 오류를 처리하기 위해 부가 프로토콜 기능
	0.	수신자 피드백: 긍정 확인응답(ACK, 1) 부정 확인응답(NAK, 0)
	0.	오류 검출: 수신자가 검출할 수 있어야 함, checksum
	0.	재전송: 송신자에 의해 재전송

한계:
	⁃	2.0의 치명적 오류ACK/NAK도 에러가 발생할 수 있음! 이 때 순서번호(sequence number)를 삽입하는 방식을 이용한다.수신된 패킷의 순서번호는 가장 최근에 수신된 패킷과 동일한 순서번호를 갖는다.0~100까지 수신이 완료 되었는데, 다음 패킷이 150부터 시작한다면 149까지 전송되지 않았음을 알 수 있기에 재전송한다. -> 2.1



rdt 2.1

송신부
과정
garbled ACK/NAK가 오면 초기 상태로 가고 0번 패킷이 내려오기를 기다린다.
	0.	rdt_send() 이벤트가 생기면 패킷을 만들어 시퀀스 0을 넣고 ACK/NAK을 기다린다.
	0.	만약 ACK/NAK이 손상되지도 않고 ACK을 받았다면, 다음 1번 패킷을 기다리는 상태가 됨.
	0.	송신부는 1번을 넣어 보내고 ACK이면 다시 0번 상태가 된다.


수신부
과정
	0.	손상되지도 않고 기다리는 시퀀스와 일치하면 ACK을 보내고 다음 시퀀스를 기다리는 상태로 전환
	0.	받은 패킷 내 시퀀스가 다르다면 ACK은 보내고 상태를 바꾸지 않음.
	0.	만약 손상되었다면 수신자는 NAK을 전송하고 이 대신, 가장 최근 정확하게 수신된 패킷에 대해 ACK을 송신함으로써 같은 효과를 냄.(중복ACK) -> rdt 2.2

한계
	⁃	state가 두 배로 필요함.
	⁃	송신측은 패킷이 중복되었는지 꼭 체크하여야 함.
	⁃	최종 ACK/NAK 메시지에 대해 잘 알지 못함(NAK을 보냈는데 ACK으로 바뀌게 되면 대참사)


rdt 2.2

정의
	•	NAK을 사용하지 않음. 최근 받은 패킷에 대해서만 ACK을 보내면 시스템의 무게감을 줄일 수 있음.
	•	현 상황에 오류가 있을 때 이전 ACK메시지를 보냄으로써 중복 ACK을 줄일 수 있음.



송신측

과정
	0.	초기 상태는 0을 기다리는 상태
	0.	rdt_send()이벤트가 일어나고 시퀀스 0을 넣어 패킷 전송
	0.	0이 있는 ACK이 오기를 기다림
	0.	1이 있는 ACK을 받는다면, NAK으로 간주한다.



수신측

	0.	도착한 패킷이 시퀀스도 일치하고 에러가 없다면 ACK1을 보냄
	0.	시퀀스가 0인 패킷을 받아야 하지만 1인 패킷을 받으면 ACK1을 보낸다



rdt 3.0

가정: 비트 에러가 있으며 하위채널이 패킷(data, ACKs)을 손실하는 경우.	checksum, seq, #, ACKs, retransmissions 등.. 하지만 부족함.

	stop-and-wait 방식을 거치기 때문에 만약 패킷이 한참 늦게 간다면 지연이 크게 발생함.
	따라서 송신 후 합리적인 시간동안 기리고 ACK이 없으면 다시 보내기로 한다.
	seq 0,1만 사용한다고 생각하며, start_timer 추가됨



과정
	0.	매 패킷이 송신된 시간에 타이머를 시작
	0.	ACK 0을 기다리는 상태로 전환. 타이머 인터럽트에 반응
	0.	타임아웃이 된다면 다시 보내고 다시 타이머를 킴.
	0.	원하는 ACK 0이 오면 타이머를 멈춘다



상황들
	0.	무손실
	0.	패킷 손실
	0.	ACK 손실 - 패킷1을 다시 보내기 때문에 그렇게 효율적이지 않음
	0.	조급한 타임아웃


rdt의 주요 구성 요소
	0.	CheckSum
	0.	Error FeedBack(ACK/NAK)
	0.	Sequence Number
	0.	Countdown Timer


3.4.2 파이프라인 rdt

요구사항
	0.	순서번호의 범위가 커져야 함: 확인응답이 안된 패킷이 있을 수 있기 때문에 각 패킷은 유일한 번호를 가져야 함
	0.	프로토콜의 rcv - sdr은 한 패킷 이상을 버퍼링해야 함: 최소한 송신자는 전송되었으나, 확인응답 되지 않은 패킷을 버퍼링해야 함.
	0.	정확하게 수신된 패킷의 버퍼링은 sdr에게도 필요함: 필요한 순서번호의 범위와 버퍼링 조건은 손실, 손상,지연된 패킷에 대한 응답 방법이 다수 존재.



파이프라인을 활용한 프로토콜
	0.	Go-Back-N기존의 Stop-and-Wait 방식 대신 기다리지 않고 N개의 패킷을 전송하도록 하는 것sdr는 각 패킷을 보낼 때 마다 타이머를 작동 -> 타이머가 끝나면 unakced인 모든 패킷을 재전송 함


window size: ACK을 받지 않고도 보낼 수 있는 (임의의)최대 패킷 수 = N프로토콜이 동작할 때 윈도우가 오른쪽으로 이동한다(slide). cumulative(축적된) ACK을 포함함.loss 발생 시 확인된 마지막 프레임 이후 보내진 프레임을 재전송한다.	1. NAK 수신
	2. loss	3. timeoutN으로 제한하는 이유: 혼잡제어가 필요하기 때문(오버버퍼링 방지)



	0.	Selective Repeatindividual ACK타이머가 동작되고 있는 unacked 패킷에 대해서만 재전송함
두 가지 방법이 있음.























